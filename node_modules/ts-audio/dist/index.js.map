{"version":3,"file":"index.js","sources":["../src/audio/utils.ts","../src/audio/states.ts","../src/EventEmitter.ts","../src/EventHandler.ts","../src/audio/initializeSource.ts","../src/audio/Audio.ts","../src/audio/AudioCtx.ts","../src/audio/decodeAudioData.ts","../src/playlist/playAudio.ts","../src/playlist/states.ts","../src/playlist/AudioPlaylist.ts","../src/playlist/utils.ts"],"sourcesContent":["/**\n * Fetches an audio file and returns it as an ArrayBuffer.\n */\nexport const getBuffer = (file: string): Promise<ArrayBuffer> =>\n  fetch(file).then((response) => {\n    if (!response.ok) {\n      throw new Error(`HTTP error, status = ${response.status}`)\n    }\n\n    return response.arrayBuffer()\n  })\n\n/**\n * Throws a formatted error with the ts-audio prefix.\n */\nexport const throwsError = (value: string): void => {\n  throw new Error(`\\`ts-audio\\`: ${value}`)\n}\n\n/**\n * Attempts to preload an audio file with automatic retry mechanism.\n * Will recursively retry loading the file up to the specified number of attempts.\n */\nexport const preloadFile = (file: string, attempts = 3, done?: () => void): void => {\n  fetch(file)\n    .then(done)\n    .catch(() => {\n      if (!attempts) {\n        return\n      }\n\n      preloadFile(file, attempts - 1)\n    })\n}\n","/**\n * Type definition for the audio player's internal state.\n */\nexport type AudioState = {\n  isDecoded: boolean\n  isPlaying: boolean\n  hasStarted: boolean\n  source: AudioBufferSourceNode | null\n  gainNode: GainNode | null\n}\n\n/**\n * Default initial state for audio decoding and playback.\n */\nexport const defaultStates: AudioState = {\n  isDecoded: false,\n  isPlaying: false,\n  hasStarted: false,\n  source: null,\n  gainNode: null,\n}\n","/**\n * Represents an event with associated data.\n */\nexport type Event = {\n  /**\n   * The data associated with the event. The type of data is unknown.\n   */\n  data: unknown\n}\n\n/**\n * Event emitter class that allows registering event listeners and emitting events.\n */\nexport class EventEmitter {\n  /**\n   * A map of event keys to their respective callback functions.\n   * @private\n   */\n  private events: { [key: string]: (param: Event) => void }\n\n  /**\n   * Initializes a new instance of the EventEmitter class.\n   */\n  constructor() {\n    this.events = {}\n  }\n\n  /**\n   * Registers a listener for a specific event key.\n   *\n   * @param {string} keyEvent - The key of the event to listen for.\n   * @param {(param: Event) => void} callback - The callback function to be invoked when the event is emitted.\n   */\n  public listener(keyEvent: string, callback: (param: Event) => void): void {\n    this.events[keyEvent] = callback\n  }\n\n  /**\n   * Emits an event, invoking the corresponding listener with the provided parameter.\n   *\n   * @param {string} keyEvent - The key of the event to emit.\n   * @param {Event} param - The parameter to pass to the event's callback function.\n   */\n  public emit(keyEvent: string, param: Event): void {\n    if (this.events[keyEvent]) {\n      this.events[keyEvent](param)\n    }\n  }\n}\n","import type { EventEmitter } from './EventEmitter'\n\ntype callbackType = <T>(param: { [data: string]: T }) => void\n\n/**\n * EventHandler class to manage event listeners for an audio context.\n */\nexport class EventHandler {\n  private emitter: EventEmitter\n  private audioCtx: AudioContext | undefined\n\n  /**\n   * Creates an instance of EventHandler.\n   * @param emitter - The event emitter instance to manage event listeners.\n   * @param audioCtx - AudioContext instance to monitor state changes. Optional to facilitate testing.\n   */\n  constructor(emitter: EventEmitter, audioCtx?: AudioContext) {\n    this.emitter = emitter\n    this.audioCtx = audioCtx\n  }\n\n  /**\n   * Registers a callback for the 'decoded' event.\n   * @param callback - The callback to be invoked when the event occurs.\n   */\n  public ready(callback: callbackType) {\n    this.emitter.listener('decoded', callback)\n  }\n\n  /**\n   * Registers a callback for the 'start' event.\n   * @param callback - The callback to be invoked when the event occurs.\n   */\n  public start(callback: callbackType) {\n    this.emitter.listener('start', callback)\n  }\n\n  /**\n   * Registers a callback for the 'end' event.\n   * @param callback - The callback to be invoked when the event occurs.\n   */\n  public end(callback: callbackType) {\n    this.emitter.listener('end', callback)\n  }\n\n  /**\n   * Monitors the state changes of the AudioContext and invokes the callback.\n   * @param callback - The callback to be invoked when the AudioContext state changes.\n   */\n  public state(callback: callbackType) {\n    if (!this.audioCtx) return\n\n    this.audioCtx.onstatechange = () => callback({ data: this.audioCtx?.state })\n  }\n}\n","import type { EventEmitter } from '../EventEmitter'\nimport type { AudioState } from './states'\n\ntype InitializeSourceConfig = {\n  audioCtx: AudioContext\n  volume: number\n  emitter: EventEmitter\n  states: AudioState\n}\n\n/**\n * Initializes and configures an audio source node with gain control.\n * Sets up the audio processing chain and configures event handling for playback completion.\n *\n * @param {InitializeSourceConfig} config - Configuration object containing:\n *   - audioCtx: Web Audio API context\n *   - volume: Initial volume level (0 to 1)\n *   - emitter: Event emitter for broadcasting audio events\n *   - states: State management object for tracking audio state\n * @returns {void}\n * @emits {Event} 'end' - Emitted when audio playback completes\n */\nexport const initializeSource = ({\n  audioCtx,\n  volume,\n  emitter,\n  states,\n}: InitializeSourceConfig): void => {\n  const source = (states.source = audioCtx.createBufferSource())\n  const gainNode = (states.gainNode = audioCtx.createGain())\n\n  gainNode.gain.value = volume\n  gainNode.connect(audioCtx.destination)\n  source.connect(gainNode)\n\n  source.onended = () => {\n    states.hasStarted = false\n    states.isPlaying = false\n    emitter.emit('end', { data: null })\n  }\n}\n","import { AudioCtx } from './AudioCtx'\nimport { defaultStates } from './states'\nimport { EventEmitter } from '../EventEmitter'\nimport { EventHandler } from '../EventHandler'\nimport { decodeAudioData } from './decodeAudioData'\nimport { initializeSource } from './initializeSource'\nimport { getBuffer, preloadFile } from './utils'\n\n/**\n * Configuration options for creating an Audio instance.\n */\ntype AudioProp = {\n  /** Path or URL to the audio file */\n  file: string\n  /** Initial volume level (0 to 1) */\n  volume?: number\n  /** Time in seconds to start playback */\n  time?: number\n  /** Whether to start playing automatically */\n  autoPlay?: boolean\n  /** Whether to loop the audio */\n  loop?: boolean\n  /** Whether to preload the audio file */\n  preload?: boolean\n}\n\n/**\n * Valid event types that can be emitted by the Audio instance.\n */\ntype AudioEvent = 'ready' | 'start' | 'state' | 'end'\n\n/**\n * If `AudioContext` is initialized before a user gesture on the page, its\n * state becomes `suspended` by default. Once `AudioContext.state` is `suspended`,\n * the only way to start it after a user gesture is executing the `resume` method.\n */\nconst start = (audioCtx: AudioContext, source: AudioBufferSourceNode, time: number) =>\n  audioCtx.state === 'suspended'\n    ? audioCtx.resume().then(() => source.start(0, time))\n    : source.start(0, time)\n\n/**\n * Audio player class that provides control over a single audio file.\n * Implements the AudioType interface for managing audio playback, volume, and events.\n */\nexport class AudioClass {\n  /** @private Path or URL to the audio file */\n  private _file: AudioProp['file']\n  /** @private Initial volume level set during construction */\n  private _initialVolume: number\n  /** @private Initial time in seconds to start playback */\n  private _initialTime: number\n  /** @private Flag indicating if audio should play automatically */\n  private _autoPlay: boolean\n  /** @private Initial loop state set during construction */\n  private _initialLoop: boolean\n  /** @private Web Audio API context */\n  private _audioCtx: AudioContext\n  /** @private Internal state management object */\n  private _states: typeof defaultStates\n  /** @private Event emitter for handling audio events */\n  private _emitter: EventEmitter\n  /** @private Event handler for managing event subscriptions */\n  private _eventHandler: EventHandler\n  /** @private Track when playback started for currentTime calculation */\n  private _startTime = 0\n  /** @private Track pause position for accurate seeking */\n  private _pauseTime = 0\n  /** @private Flag to track if seeking occurred while audio was paused */\n  private _hasSeekedWhilePaused = false\n\n  /**\n   * Creates an instance of Audio player.\n   *\n   * @param {AudioProp} config - The audio configuration object\n   * @param {string} config.file - Path or URL to the audio file\n   * @param {number} [config.volume=1] - Initial volume level (0 to 1)\n   * @param {number} [config.time=0] - Time in seconds to start playback\n   * @param {boolean} [config.autoPlay=false] - Whether to start playing automatically\n   * @param {boolean} [config.loop=false] - Whether to loop the audio\n   * @param {boolean} [config.preload=false] - Whether to preload the audio file\n   */\n  constructor({\n    file,\n    volume = 1,\n    time = 0,\n    autoPlay = false,\n    loop = false,\n    preload = false,\n  }: AudioProp) {\n    this._file = file\n    this._initialVolume = volume\n    this._initialTime = time\n    this._autoPlay = autoPlay\n    this._initialLoop = loop\n    this._audioCtx = AudioCtx()\n    this._states = { ...defaultStates }\n    this._emitter = new EventEmitter()\n    this._eventHandler = new EventHandler(this._emitter, this._audioCtx)\n\n    if (preload) {\n      preloadFile(file)\n    }\n  }\n\n  /**\n   * Recreates source and starts playback at specified time.\n   * @private\n   * @param {number} time - Time in seconds to start playback\n   * @param {AudioBuffer} buffer - The audio buffer to use\n   */\n  private recreateAndStart(time: number, buffer: AudioBuffer): void {\n    try {\n      // Stop current source if playing\n      if (this._states.source) {\n        this._states.source.stop(0)\n        this._states.source.onended = null\n      }\n\n      initializeSource({\n        audioCtx: this._audioCtx,\n        volume: this._states.gainNode?.gain.value ?? this._initialVolume,\n        emitter: this._emitter,\n        states: this._states,\n      })\n\n      const { source } = this._states\n\n      if (source) {\n        source.buffer = buffer\n        source.loop = this._initialLoop\n\n        start(this._audioCtx, source, time)\n        this._startTime = this._audioCtx.currentTime\n        this._pauseTime = time\n        this._states.isPlaying = true\n        this._states.hasStarted = true\n      }\n    } catch (error) {\n      console.error('Failed to recreate audio source:', error)\n      this._states.isPlaying = false\n    }\n  }\n\n  /**\n   * Fetches and decodes the audio buffer for the given source node.\n   * @private\n   * @param {AudioBufferSourceNode} source - The audio source node to load buffer into\n   */\n  private curryGetBuffer(source: AudioBufferSourceNode): void {\n    this._states.isDecoded = false\n\n    getBuffer(this._file)\n      .then((arrayBuffer) => {\n        decodeAudioData({\n          audioCtx: this._audioCtx,\n          source,\n          arrayBuffer,\n          autoPlay: this._autoPlay,\n          loop: this._initialLoop,\n          states: this._states,\n          emitter: this._emitter,\n        })\n      })\n      .catch(console.error)\n  }\n\n  /**\n   * Starts or resumes audio playback.\n   * If playback hasn't started, initializes audio source and begins playback.\n   * If playback was paused, resumes from the current position.\n   * If seeking occurred while paused, recreates the source at the new position.\n   */\n  public play(): void {\n    if (this._states.hasStarted && !this._hasSeekedWhilePaused) {\n      this._audioCtx.resume()\n      this._startTime = this._audioCtx.currentTime\n      this._states.isPlaying = true\n      return\n    }\n\n    // If seeked while paused, recreate source at the new position\n    if (this._hasSeekedWhilePaused && this._states.source?.buffer) {\n      const audioBuffer = this._states.source.buffer\n      this.recreateAndStart(this._pauseTime, audioBuffer)\n      this._hasSeekedWhilePaused = false\n      return\n    }\n\n    initializeSource({\n      audioCtx: this._audioCtx,\n      volume: this._initialVolume,\n      emitter: this._emitter,\n      states: this._states,\n    })\n\n    const { source } = this._states\n\n    if (source) {\n      this.curryGetBuffer(source)\n\n      if (this._states.isDecoded) {\n        start(this._audioCtx, source, this._pauseTime ?? this._initialTime)\n        this._startTime = this._audioCtx.currentTime\n      } else {\n        this._emitter.listener('decoded', () => {\n          start(this._audioCtx, source, this._pauseTime ?? this._initialTime)\n          this._startTime = this._audioCtx.currentTime\n        })\n      }\n\n      this._states.hasStarted = true\n      this._states.isPlaying = true\n      this._emitter.emit('start', { data: null })\n    }\n  }\n\n  /**\n   * Pauses audio playback by suspending the audio context.\n   */\n  public pause(): void {\n    if (this._states.isPlaying) {\n      this._pauseTime = this.currentTime\n    }\n\n    this._audioCtx.suspend()\n    this._states.isPlaying = false\n    this._hasSeekedWhilePaused = false\n  }\n\n  /**\n   * Toggles between play and pause states.\n   */\n  public toggle(): void {\n    this._states.isPlaying ? this.pause() : this.play()\n  }\n\n  /**\n   * Stops audio playback completely.\n   * Different from pause as it resets the playback position.\n   */\n  public stop(): void {\n    if (this._states.hasStarted) {\n      this._states.source?.stop(0)\n      this._states.isPlaying = false\n    }\n  }\n\n  /**\n   * Subscribes to audio events.\n   * @param {AudioEvent} eventType - Type of event to listen for\n   * @param {Function} callback - Function to call when event occurs\n   */\n  public on(eventType: AudioEvent, callback: <T>(param: { [data: string]: T }) => void): void {\n    this._eventHandler[eventType]?.(callback)\n  }\n\n  /**\n   * Gets the current volume level.\n   * @returns {number} Current volume value between 0 and 1\n   */\n  public get volume(): number {\n    return this._states.gainNode?.gain.value ?? 0\n  }\n\n  /**\n   * Sets the audio volume level.\n   * @param {number} newVolume - New volume value between 0 and 1\n   */\n  public set volume(newVolume: number) {\n    if (this._states.gainNode) {\n      this._states.gainNode.gain.value = newVolume\n    }\n  }\n\n  /**\n   * Gets the current loop state.\n   * @returns {boolean} Whether audio is set to loop\n   */\n  public get loop(): boolean {\n    return this._states.source?.loop ?? false\n  }\n\n  /**\n   * Sets the loop state.\n   * @param {boolean} newLoop - Whether audio should loop\n   */\n  public set loop(newLoop: boolean) {\n    if (this._states.source) {\n      this._states.source.loop = newLoop\n    }\n  }\n\n  /**\n   * Gets the current state of the audio context.\n   * @returns {AudioContextState} Current state of the audio context\n   */\n  public get state(): AudioContextState {\n    return this._audioCtx.state\n  }\n\n  /**\n   * Gets the current AudioContext instance.\n   * @returns {AudioContext} The current AudioContext instance\n   */\n  public get audioCtx(): AudioContext {\n    return this._audioCtx\n  }\n\n  /**\n   * Gets the total duration of the loaded audio in seconds.\n   * @returns {number} The duration of the audio if available; otherwise, returns 0.\n   */\n  public get duration(): number {\n    return this._states.source?.buffer?.duration ?? 0\n  }\n\n  /**\n   * Gets the current playback position in seconds.\n   * @returns {number} The current playback position if available; otherwise, returns 0.\n   */\n  public get currentTime(): number {\n    if (!this._states.hasStarted) {\n      return 0\n    }\n\n    if (!this._states.isPlaying) {\n      return this._pauseTime\n    }\n\n    return this._pauseTime + (this._audioCtx.currentTime - this._startTime)\n  }\n\n  /**\n   * Seeks to a specific time position in the audio track.\n   * @param {number} time - Time in seconds to seek to (0 ≤ time ≤ duration)\n   */\n  public seek(time: number): void {\n    if (!this._states.source?.buffer || !this._states.isDecoded) {\n      return\n    }\n\n    // Clamp time to valid bounds\n    time = Math.max(0, Math.min(time, this.duration))\n\n    const wasPlaying = this._states.isPlaying\n    const audioBuffer = this._states.source.buffer\n\n    // Stop current source if playing\n    if (this._states.source && wasPlaying) {\n      // Temporarily remove onended handler to prevent false \"end\" events during seek\n      this._states.source.onended = null\n\n      try {\n        this._states.source.stop(0)\n      } catch (error) {\n        console.error('Error stopping audio source:', error)\n      }\n    }\n\n    if (wasPlaying) {\n      // Recreate source and start playing at new position\n      this.recreateAndStart(time, audioBuffer)\n    } else {\n      // Just update pause position for paused audio\n      this._pauseTime = time\n      this._hasSeekedWhilePaused = true\n    }\n  }\n}\n\n/**\n * Factory function to create a new Audio instance.\n *\n * @param {AudioPropType} props - The audio configuration properties\n * @returns {AudioType} A new Audio instance\n */\nexport default (props: AudioProp): AudioClass => new AudioClass(props)\n","import { throwsError } from './utils'\n\ndeclare global {\n  interface Window {\n    webkitAudioContext: typeof window.AudioContext\n  }\n}\n\n/**\n * Creates and returns a new AudioContext instance with cross-browser support.\n * Attempts to use standard AudioContext first, falls back to webkitAudioContext for older browsers.\n *\n * @returns {AudioContext} A new AudioContext instance\n * @throws {Error} If the browser doesn't support AudioContext\n */\nexport const AudioCtx = (): AudioContext => {\n  const Context = window.AudioContext || window.webkitAudioContext\n\n  if (!Context) {\n    throwsError(\"Your browser doesn't support AudioContext - https://bit.ly/2YWmpnX\")\n  }\n\n  return new Context()\n}\n","import type { AudioState } from './states'\nimport type { EventEmitter } from '../EventEmitter'\n\n/**\n * Configuration options for audio decoding\n */\ntype DecodeAudioDataConfig = {\n  /** The Web Audio API context */\n  audioCtx: AudioContext\n  /** The audio source node to configure */\n  source: AudioBufferSourceNode\n  /** The raw audio data to decode */\n  arrayBuffer: ArrayBuffer\n  /** Whether to start playback immediately after decoding */\n  autoPlay: boolean\n  /** Whether the audio should loop when playing */\n  loop: boolean\n  /** State object to track decoding and playback status */\n  states: AudioState\n  /** Event emitter to broadcast decode completion */\n  emitter: EventEmitter\n}\n\n/**\n * Decodes audio data from an ArrayBuffer and configures the audio source node.\n * On successful decode, sets up the audio buffer, configures looping, and optionally starts playback.\n *\n * @param {DecodeAudioDataConfig} config - Configuration object containing all necessary parameters\n * @returns {void}\n * @emits {Event} 'decoded' - Emitted when audio data is successfully decoded, includes the AudioBuffer\n */\nexport const decodeAudioData = ({\n  audioCtx,\n  source,\n  arrayBuffer,\n  autoPlay,\n  loop,\n  states,\n  emitter,\n}: DecodeAudioDataConfig): void => {\n  const onSuccess = (buffer: AudioBuffer) => {\n    source.buffer = buffer\n    source.loop = loop\n\n    states.isDecoded = true\n    emitter.emit('decoded', { data: buffer })\n\n    if (autoPlay) {\n      source.start(0)\n      states.isPlaying = true\n    }\n  }\n\n  audioCtx.decodeAudioData(arrayBuffer, onSuccess, console.error)\n}\n","import type { Event, EventEmitter } from '../EventEmitter'\nimport type { AudioPlaylistState } from './states'\n\nimport Audio from '../audio/Audio'\n\n/**\n * Creates an audio playback controller function that manages playlist state and events.\n *\n * @param {AudioPlaylistState} states - Global state object containing audio playback states\n * @param {EventEmitter} emmiter - Event emitter for handling playlist events\n * @returns {(files: string[], loop: boolean) => void} A function that handles audio playback\n */\nconst playAudio = (\n  states: AudioPlaylistState,\n  emmiter: EventEmitter,\n): ((files: string[], loop: boolean) => void) => {\n  const playAudioHelper = (files: string[], loop: boolean) => {\n    const file = files[states.audioIndex]\n    const audio = Audio({ file, volume: states.volume })\n    states.audio = audio\n\n    audio.on('start', (e) => {\n      emmiter.emit('start', e as Event)\n    })\n\n    audio.on('end', () => {\n      if (states.isStopped) return\n\n      if (files.length === states.audioIndex + 1) {\n        states.audio = null\n        states.audioIndex = 0\n\n        if (states.loop) {\n          playAudioHelper(files, loop)\n        } else {\n          emmiter.emit('end', { data: null })\n          states.isPlaying = false\n        }\n      } else {\n        states.audioIndex++\n        playAudioHelper(files, loop)\n      }\n    })\n\n    audio.play()\n  }\n\n  return playAudioHelper\n}\n\nexport default playAudio\n","import type { AudioClass } from '../audio/Audio'\n\n/**\n * Represents the global state for an audio playlist.\n */\nexport type AudioPlaylistState = {\n  volume: number\n  loop: boolean\n  audio: AudioClass | null\n  isStopped: boolean\n  isPlaying: boolean\n  audioIndex: number\n}\n\n/**\n * Default initial state for the audio playlist.\n */\nconst states: AudioPlaylistState = {\n  volume: 1,\n  loop: false,\n  audio: null,\n  isStopped: false,\n  isPlaying: false,\n  audioIndex: 0,\n}\n\nexport default states\n","/**\n * @fileoverview Audio playlist manager that handles playback of multiple audio files\n * with features like shuffle, loop, and weighted random selection.\n */\n\nimport Audio from '../audio/Audio'\nimport { EventEmitter } from '../EventEmitter'\nimport playAudio from './playAudio'\nimport globalStates from './states'\nimport { shuffle as shuffleHelper, weightedFiles, preloadFiles } from './utils'\n\n/**\n * Configuration options for initializing an AudioPlaylist instance.\n */\ntype AudioPlaylistConfig = {\n  files: string[] | { [key: string]: number }\n  volume?: number\n  loop?: boolean\n  shuffle?: boolean\n  preload?: boolean\n  preloadLimit?: number\n}\n\n/**\n * Events that can be emitted by the AudioPlaylist.\n */\ntype AudioPlaylistEvent = 'start' | 'end'\n\n/**\n * Manages audio playlist functionality including playback control, file management,\n * and event handling.\n */\nclass AudioPlaylist {\n  /** Event emitter for handling playlist events */\n  private emmiter: EventEmitter\n  /** Global state object containing audio playback states */\n  private states: typeof globalStates\n  /** Array of audio file paths to be played */\n  private copiedFiles: string[]\n  /** Flag indicating if playlist should loop */\n  private shouldLoop: boolean\n  /** Curried function for playing audio files */\n  private curryPlayAudio: ReturnType<typeof playAudio>\n\n  /**\n   * Creates an instance of AudioPlaylist.\n   * @param {Object} config - The playlist configuration\n   * @param {(string[] | Record<string, number>)} config.files - Array of audio files or weighted object\n   * @param {number} [config.volume=1] - Initial volume level (0-1)\n   * @param {boolean} [config.loop=false] - Whether to loop the playlist\n   * @param {boolean} [config.shuffle=false] - Whether to shuffle the playlist\n   * @param {boolean} [config.preload=false] - Whether to preload audio files\n   * @param {number} [config.preloadLimit=3] - Number of files to preload\n   */\n  constructor({\n    files,\n    volume = 1,\n    loop = false,\n    shuffle = false,\n    preload = false,\n    preloadLimit = 3,\n  }: AudioPlaylistConfig) {\n    this.emmiter = new EventEmitter()\n    this.states = { ...globalStates, ...{ volume, loop } }\n\n    const hasWeights = !Array.isArray(files)\n    this.shouldLoop = loop || hasWeights\n\n    const normalizedFiles: string[] = hasWeights\n      ? weightedFiles(files as { [key: string]: number })\n      : (files as string[])\n\n    this.copiedFiles =\n      shuffle || hasWeights ? shuffleHelper(normalizedFiles) : normalizedFiles.slice()\n\n    this.curryPlayAudio = playAudio(this.states, this.emmiter)\n\n    if (preload) {\n      preloadFiles(this.copiedFiles, preloadLimit)\n    }\n  }\n\n  /**\n   * Starts or resumes audio playback.\n   * If no audio is playing or playback was stopped, starts from current position.\n   */\n  play(): void {\n    const { audio } = this.states\n    this.states.isPlaying = true\n\n    if (!audio || this.states.isStopped) {\n      this.curryPlayAudio(this.copiedFiles, this.shouldLoop)\n      this.states.isStopped = false\n      return\n    }\n\n    audio.play()\n  }\n\n  /**\n   * Toggles between play and pause states.\n   */\n  toggle(): void {\n    this.states.isPlaying ? this.pause() : this.play()\n  }\n\n  /**\n   * Pauses the current audio playback.\n   */\n  pause(): void {\n    this.states.audio?.pause()\n    this.states.isPlaying = false\n  }\n\n  /**\n   * Stops the current audio playback and resets the player.\n   */\n  stop(): void {\n    this.states.isPlaying = false\n    this.states.isStopped = true\n    this.states.audio?.stop()\n  }\n\n  /**\n   * Plays the next audio file in the playlist sequence.\n   * Handles wrapping back to the beginning when reaching the end of the playlist.\n   */\n  next(): void {\n    const isLastFile = this.states.audioIndex === this.copiedFiles.length - 1\n    this.states.audioIndex = isLastFile ? 0 : this.states.audioIndex + 1\n\n    this.states.audio?.pause()\n\n    const file = this.copiedFiles[this.states.audioIndex]\n    const audio = Audio({ file, volume: this.states.volume })\n\n    this.states.audio = audio\n    audio.play()\n  }\n\n  /**\n   * Plays the previous audio file in the playlist sequence.\n   * Handles wrapping to the end of the playlist when at the beginning.\n   */\n  prev(): void {\n    const isFirstFile = this.states.audioIndex === 0\n    this.states.audioIndex = isFirstFile ? this.copiedFiles.length - 1 : this.states.audioIndex - 1\n\n    this.states.audio?.pause()\n\n    const file = this.copiedFiles[this.states.audioIndex]\n    const audio = Audio({ file, volume: this.states.volume })\n    this.states.audio = audio\n    audio.play()\n  }\n\n  /**\n   * Registers an event listener for playlist events.\n   * @param {AudioPlaylistEvent} eventType - Type of event to listen for\n   * @param {Function} callback - Callback function to execute when event occurs\n   */\n  on(eventType: AudioPlaylistEvent, callback: (param: { [data: string]: unknown }) => void): void {\n    this.emmiter.listener(eventType, callback)\n  }\n\n  /**\n   * Gets the current volume level.\n   * @returns {number} Current volume level (0-1)\n   */\n  get volume(): number {\n    return this.states.volume\n  }\n\n  /**\n   * Sets the volume level.\n   * @param {number} newVolume - New volume level (0-1)\n   */\n  set volume(newVolume: number) {\n    this.states.volume = newVolume\n\n    if (this.states.audio) {\n      this.states.audio.volume = newVolume\n    }\n  }\n\n  /**\n   * Gets the current loop state.\n   * @returns {boolean} Whether playlist is set to loop\n   */\n  get loop(): boolean {\n    return this.states.loop\n  }\n\n  /**\n   * Sets the loop state.\n   * @param {boolean} newLoop - New loop state\n   */\n  set loop(newLoop: boolean) {\n    this.states.loop = newLoop\n  }\n\n  /**\n   * Gets the current AudioContext instance.\n   * @returns {(AudioContext | undefined)} Current AudioContext or undefined if not initialized\n   */\n  get audioCtx(): AudioContext | undefined {\n    return this.states.audio?.audioCtx\n  }\n}\n\n/**\n * Factory function to create a new AudioPlaylist instance.\n * @param {AudioPlaylistConfig} params - Configuration parameters for the playlist\n */\nexport default (params: AudioPlaylistConfig) => new AudioPlaylist(params)\n","/**\n * Converts an object of weighted file paths into an array where each file appears\n * multiple times based on its weight.\n *\n * @example\n * weightedFiles({ 'song1.mp3': 2, 'song2.mp3': 1 })\n * // returns ['song1.mp3', 'song1.mp3', 'song2.mp3']\n *\n * @param {Object.<string, number>} files - Object with file paths as keys and weights as values\n * @returns {string[]} Array of file paths repeated according to their weights\n */\nexport const weightedFiles = (files: { [key: string]: number }): string[] => {\n  return Object.entries(files).flatMap(([file, weight]) => Array(Math.floor(weight)).fill(file))\n}\n\n/**\n * Shuffles an array of strings using the Fisher-Yates algorithm.\n * Creates a new array instead of modifying the original.\n *\n * @example\n * shuffle(['a', 'b', 'c'])\n * // might return ['b', 'c', 'a']\n *\n * @param {string[]} list - Array of strings to shuffle\n * @returns {string[]} New array with shuffled elements\n */\nexport const shuffle = (list: string[]): string[] => {\n  const result = list.slice()\n  let index = list.length - 1\n\n  while (index >= 0) {\n    const randomIdx = Math.floor(Math.random() * index + 1)\n    const tmp = result[index]\n    result[index] = result[randomIdx]\n    result[randomIdx] = tmp\n\n    index--\n  }\n\n  return result\n}\n\n/**\n * Preloads audio files in batches with a specified limit.\n * Uses a queue system to load files sequentially after the initial batch.\n *\n * @param {string[]} files - Array of file URLs to preload\n * @param {number} limit - Maximum number of files to load simultaneously\n * @param {Function} [api=fetch] - Function to use for fetching files\n * @param {Function} [done] - Callback function to execute when all files are loaded\n */\nexport const preloadFiles = (\n  files: string[],\n  limit: number,\n  api: (input: string, init?: RequestInit | undefined) => Promise<Response> = fetch,\n  done?: () => void,\n): void => {\n  const queue: string[] = files.slice(limit).reverse()\n  let isDone = false\n\n  /**\n   * Processes the next item in the queue or calls the done callback if queue is empty\n   */\n  const requestNext = () => {\n    if (!queue.length) {\n      if (!isDone) {\n        done?.()\n        isDone = true\n      }\n    } else {\n      request(queue.pop() as string)\n    }\n  }\n\n  const request = (fileName: string) => {\n    api(fileName).then(requestNext).catch(requestNext)\n  }\n\n  for (let i = 0; i < limit; i++) {\n    request(files[i])\n  }\n}\n"],"names":["preloadFile","file","attempts","done","fetch","then","catch","defaultStates","isDecoded","isPlaying","hasStarted","source","gainNode","EventEmitter","constructor","events","this","listener","keyEvent","callback","emit","param","EventHandler","emitter","audioCtx","ready","start","end","state","onstatechange","data","initializeSource","volume","states","createBufferSource","createGain","gain","value","connect","destination","onended","time","resume","AudioClass","autoPlay","loop","preload","_file","_initialVolume","_initialTime","_autoPlay","_initialLoop","_audioCtx","_states","_emitter","_eventHandler","_startTime","_pauseTime","_hasSeekedWhilePaused","AudioCtx","Context","window","AudioContext","webkitAudioContext","Error","throwsError","recreateAndStart","buffer","stop","currentTime","error","console","curryGetBuffer","response","ok","status","arrayBuffer","decodeAudioData","play","pause","suspend","toggle","on","eventType","newVolume","newLoop","duration","seek","Math","max","min","wasPlaying","audioBuffer","Audio","props","audio","isStopped","audioIndex","AudioPlaylist","files","shuffle","preloadLimit","emmiter","copiedFiles","shouldLoop","curryPlayAudio","globalStates","hasWeights","Array","isArray","normalizedFiles","Object","entries","flatMap","weight","floor","fill","weightedFiles","list","result","slice","index","length","randomIdx","random","tmp","shuffleHelper","playAudio","playAudioHelper","e","preloadFiles","limit","api","queue","reverse","isDone","requestNext","request","pop","fileName","i","next","prev","params"],"mappings":"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"}